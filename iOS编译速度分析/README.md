## 编译相关的技术
#### PCH文件
在这个文件中的头文件都只会被编译一次并缓存下来，然后加入到所有头文件中去。（但真正需要被全局依赖的文件很少，且PCH文件一但电话，所有文件都要被重新编译）
#### Clang modules
可以用``@import``来代替``#import``，可以理解为模块化的PCH，具备了可以缓存头文件的优点，同时能提供更细粒度的引用。
#### CCache
基于编译器的缓存，但CCache不支持PCH文件和Clang modules

### 日常开发
默认情况下，xcode会使用上次编译时留下的缓存，即增量编译。

#### 耗时分析
- 增量编译：只有头文件不变的编译单元能被缓存，如果某个文件被N个文件import，当这个文件的头文件发生变化，所有import的文件都要重新编译

- 链接：链接没有缓存，而且只能单核进行，因此它的耗时取决于单核性能和磁盘读写速度
- 调试信息：日常开发不需要dSYM文件（主要用在崩溃时查找调用栈），可以关闭这个功能


### 持续集成
持续集成时，会使用``xcodebuild archive``（本地打包，需要选择真机才有archive），自动忽略缓存，每次都要全部重新编译。

## 优化方案
- **使用@class减少import，减少.h文件的行数**，预编译时会把import的头文件复制到对应文件中
- **常变的宏慎写在头文件** 
- **常变的头文件慎加入Precompiled Header File（PCH）** 
- **关闭dSYM文件**
- **使用多核高配MacBook**
- **精简指令集**。只要armv7兜底，牺牲运行时性能换取编译速度
- **关闭编译器优化**，Optimize level 改成 None。优化的基本原理是牺牲编译时性能，追求运行时性能，在此需反其道行之
- **二进制化，使用静态库、framework代替源码**，避免编译。静态库指.a文件，很多CocoaPods的库还是设置成源码引用的。

#### 优化参考
参考原始时间均为 45 min

|方案序号| 优化方案| 优化后耗时（min）| 时间减少百分比 | 
|:-----:|:-------------:|:-------------:|:-----:|
|1| 不常修改的文件二进制化| 25 | 44.4% | 
|2| 精简指令集| 27 | 40% | 
|3| 关闭编译优化 | 38 | 15.6% | 
|4| 使用 Mac Pro | 15 | 66.7% |
|5| 虚拟磁盘 | 42 | 6.7%| 
|6| 公司现行方案（2+3+4+5）| 9 | 80% |
|7| 黑苹果 | 5 | 88.9% |
|8| 终极方案（1+2+3+5+7）| 4（预计）| 91.1%（预计）|

## 实践
使用``xcpretty``格式化``xcodebuild``的输出，使用``gnomon``来计算相邻两行输出之间的间隔
``` 
xcodebuild -workspace YYMobile.xcworkspace -scheme YYMobile | xcpretty | gnomon
```


## 参考资料
- [张星宇：如何将 iOS 工程打包速度提升十倍以上](https://bestswifter.com/improve_compile_speed/)
- [贝聊：如何将 iOS 项目的编译速度提高5倍（CCache方案）](http://www.geekpeer.com/Development/ios/4099.html)
- [iOS编译过程的原理和应用](https://github.com/LeoMobileDeveloper/Blogs/blob/master/iOS/iOS编译过程的原理和应用.md)